---
title: "Peripherals & Descriptors"
icon: "Usb"
---

## üîå What Are Peripherals?

**Peripherals** are a concept in the Phygrid platform for connecting and managing external hardware devices that are not directly integrated into the platform itself. Examples include cameras, card readers, barcode scanners, and printers.

Just like devices or apps, peripherals have their own **twins**, which are managed by apps running on platform-enabled devices. Using peripherals, developers can easily monitor, configure, and integrate all kinds of hardware as part of their solutions.

Peripherals available in your tenant can be discovered, monitored, and configured via the Console, just like other devices or apps ‚Äî significantly improving observability and maintainability in live physical environments.

## üîÑ Peripheral Twin Lifecycle

Let's explore how peripherals work in practice by examining a door controller integration. This example demonstrates how a physical door can be managed as a peripheral twin throughout its lifecycle:

1. An edge app discovers and connects to a door controller on the local network.

2. The app creates a peripheral twin representing the detected door.

3. The edge app handles actions on the twin (e.g. open, close), controls the physical door, and emits relevant events.

4. A screen app subscribes to the door twin and reacts to events and state changes (e.g., shows door status in the UI, triggers animations) or emits door actions.

5. Door status and configuration can be monitored and managed via the Console, using the peripheral twin's properties.

Thanks to Phyhub's smart routing, messages between twins are delivered either locally (on the same device) or via the cloud, depending on the setup. This enables **cross-device twin subscriptions**‚Äîany device in your tenant can subscribe to any peripheral twin, making it easy to build complex, connected and modular solutions.

## üí™ Peripheral Flexibility

Peripherals often represent **physical hardware devices**‚Äîsuch as scanners, sensors, or access controllers.

However, in some cases, they can also represent **abstract or logical components** within a solution. For example, a "store" peripheral twin might represent whether a store is open, closed, or in maintenance mode, without being tied to any physical device.

This flexibility allows developers to standardize interactions and status reporting for both tangible and intangible parts of their system‚Äîusing the same twin and descriptor patterns throughout.

To ensure the platform understands what a peripheral twin can do, descriptors are used when creating twins.

## üìù Descriptors

To ensure the platform understands what a peripheral twin can do, **descriptors** are used when creating twins.

Descriptors define the capabilities and interface of a twin. They describe:

- **Actions** ‚Äî commands the twin can receive and respond to
- **Desired Properties** ‚Äî configuration values the twin should follow
- **Reported Properties** ‚Äî the current state of the twin, reported to the platform
- **Events** ‚Äî structured outputs that other components can subscribe to

Descriptors are created using platform tools such as the Phygrid CLI and are included when creating peripheral twins.

Let's revisit the door scenario we mentioned earlier:

1. An edge app includes a door descriptor identifier and version when creating the twin.

2. The edge app handles twin actions (e.g., open, close) and emits standardized events as defined in the descriptor (e.g., doorOpened, doorClosed) and updates twin's state through reported properties.

3. A screen app subscribes to the door twin and its events, configured via the Console.

4. The screen app receives events and reacts to door status changes‚Äîwithout needing any knowledge of the underlying hardware or control logic.

5. Importantly, the screen app does not need to run on the same device‚Äîthanks to Phyhub's routing, any subscribed device in your tenant can react to those events.

This approach ensures consistent interfaces, decouples hardware handling from the app logic, and allows developers to build modular, scalable, and reusable solutions with minimal boilerplate.

## + Benefits of Peripherals & Descriptors

- **Improved observability and monitoring** of solution hardware

- **Enables historical hardware status tracking** (with upcoming twin status history feature)

- **Better separation of concerns:**
  - Keeps low-level hardware settings out of app configs
  - Reduces noise and promotes cleaner app configuration

- **Promotes modularity and reusability** by abstracting certain hardware-specific logic away from business logic

- **Enables scalable multi-device solutions** via standardized twin interfaces

## üîÑ Next Steps

Now that you understand peripherals and descriptors, you can:

- [Configure peripheral twins in your settings schemas](/how-to/settings-schemas/)
- [Use Signals to emit events and monitor edge activity](/how-to/signals/)
- [Learn about troubleshooting and debugging](/how-to/troubleshoot-and-debug/)

