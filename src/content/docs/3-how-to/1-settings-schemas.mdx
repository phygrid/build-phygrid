---
title: "Settings Schema in the Screen/Edge Apps"
icon: "‚öôÔ∏è"
---

## ‚öôÔ∏è What Are Settings Schemas?

A **Settings Schema** is a structured definition of configuration data,
represented using **JSON Schema**. It describes the shape of the settings data
used within an application‚Äîdefining fields,
their types, constraints (like required fields or value ranges),
and how the data should be structured.

This schema acts as a contract between the data and the user interface,
especially when building dynamic forms. In our case,
the schema can be consumed by our console
to automatically generate UI forms
that match the defined settings structure.

## üéØ Purpose of the Settings Schema

The Settings Schema serves multiple purposes in the app:

- **UI Form Generation:** It enables dynamic generation
  of forms,
  reducing the need for manual UI coding.
- **Validation:** Ensures that the configuration entered by users is valid and complete.
- **Consistency:** Maintains consistency across different
  parts of the application that rely on settings.
- **Extensibility:** Makes it easier to extend or modify settings without rewriting
  large parts of the UI or validation logic.

By using a schema-driven approach, the app becomes more scalable,
predictable, and developer-friendly.

## üîß Why Use TypeScript to Define the Schema?

Rather than writing JSON Schema manually, we define the schema using
**TypeScript interfaces and types**.
This approach provides several key benefits:

- **Type Safety:** Developers get immediate feedback when types are inconsistent or misused.
- **Editor Support:** IDEs offer autocomplete, inline documentation,
  and validation based on TypeScript definitions.
- **Single Source of Truth:** Using TypeScript ensures the same definitions are used
  throughout the codebase‚Äîboth in the logic and in schema generation.
- **Maintainability:** Changes to the structure are easier to track
  and update using standard TypeScript tooling.

The TypeScript types are then automatically transformed into JSON Schema, ensuring alignment
between the developer-defined types and the generated schema.

## üîÑ How It Works

This example demonstrates how to define a simple name setting using TypeScript.
This improves maintainability
by ensuring changes to the schema are reflected automatically in the generated JSON Schema.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Background Color
   * @description The primary background color for the application interface.
   * @widget color
   * @default "#ffffff"
   */
  background: string
}
```

### üîÑ Schema Conversion

When building the application, the TypeScript interface `schema.ts`
is automatically converted into two schemas:

- `schema.json`: a standard JSON Schema used for validation and data structure.
- `meta-schema.json`: a Meta-JSON Schema that provides UI configuration, such as
  widget selection and display behaviors (e.g., mediaPicker, multiLanguageText).

This build-time conversion ensures that UI rendering, custom widgets,
and data validation are all based on a single,
developer-defined source of truth.

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "background": {
      "type": "string",
      "title": "Background Color",
      "description": "The primary background color for the application interface.",
      "default": "#ffffff"
    }
  }
}
```

**`meta-schema.json`**

```json
{
  "background": {
    "ui:widget": "color"
  }
}
```

### ‚ú® Key Benefits

- üîÑ **Single Source of Truth:** The TypeScript interface serves
  both the developer and the platform that renders the UI.
- ‚úÖ **Built-in Validation:** UI components and backend validation share the same rules,
  reducing bugs and mismatches.
- üõ†Ô∏è **Tooling Friendly:** Changes in the schema are instantly reflected in the generated forms.

## üõ†Ô∏è How to Define a Settings Schema

All Phygrid boilerplate projects include a settings schema definition by default.
When you create a new app using the CLI, you'll find a `schema.ts` file in the
`src/` directory that defines your app's configuration structure.

### üì± Screen App Example

**1Ô∏è‚É£ Create a New Screen App**

- Run the command: `phy app create`
- Enter the desired app name.
- When prompted, select:
  ‚ùØ Screen Application (React)

**2Ô∏è‚É£ Update the Settings Schema**

Edit the `schema.ts` file to define your app's configuration:

```ts
export default interface Settings {
  /**
   * @title Welcome Message
   * @description A personalized welcome message displayed to users
   * @default Hello world!
   * @minLength 1
   * @maxLength 200
   */
  welcomeMessage: string
}
```

**3Ô∏è‚É£ Access Settings in Your App**

This example works on both PhyOS devices and locally:

**`app.tsx`**

```ts
import React, { useCallback, useEffect, useState } from "react"
import styled from "styled-components"
import { connectPhyClient, PhyHubClient } from "@phygrid/hub-client"
import { getDevSettings, isDevMode } from "./utils/dev-mode"
import Settings from "./schema"

interface AppState {
  client: PhyHubClient | null
  settings: Settings | null
  signals: PhyHubClient["signals"] | null
}

const initialState: AppState = {
  client: null,
  settings: null,
  signals: null,
}

function App() {
  const [state, setState] = useState<AppState>(initialState)

  const initializeDevMode = useCallback(() => {
    setState(prev => ({
      ...prev,
      settings: getDevSettings(),
    }))
  }, [])

  const initializeClient = useCallback(async () => {
    try {
      const client = await connectPhyClient()
      const signals = await client.initializeSignals()
      const settings = (await client.getSettings()) as Settings

      setState({ client, settings, signals })
    } catch (err) {
      console.error("Error initializing client:", err)
    }
  }, [])

  useEffect(() => {
    const initialize = async () => {
      if (isDevMode()) {
        initializeDevMode()
        return
      }
      await initializeClient()
    }

    initialize()
  }, [initializeDevMode, initializeClient])

  const welcomeMessage = state.settings?.welcomeMessage

  return <Container>{welcomeMessage}</Container>
}

const Container = styled.div`
  text-align: center;
  background-color: #000000;
  height: 100%;
  position: absolute;
  display: flex;
  flex-direction: row;
  width: 100%;
  color: white;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 1.5vmin);
`

export default App
```

**4Ô∏è‚É£ Local Development**

**Step 1:** Update app settings in `src/settings/index.json`:

```json
{
  "app": {
    "gridApp": {
      "settings": {
        "welcomeMessage": "Hello World!"
      }
    }
  }
}
```

**Step 2:** Start the development server:

```bash
yarn run start
```

Now you can develop and see live updates locally.

**5Ô∏è‚É£ Deploy to PhyOS Devices**

1. **Create a new version of the app** by updating the version in `package.json` file
2. Push the new version of the app to your tenant by running the following command
   `yarn run build && yarn run pub`
3. Finally you can connect and deploy to your device. `<Link to how to connect a device to your installation>`

![Screen App](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/cd694d12-7868-419f-8064-09f46f2dda2c)

### üåê Edge App Example

**1Ô∏è‚É£ Create a New Edge App**

- Run the command: `phy app create`
- Enter the desired app name.
- When prompted, select:
  ‚ùØ Edge Application (Node.js)

**2Ô∏è‚É£ Update the Settings Schema**

**`schema.tsx`**

```ts
export default interface Settings {
  /**
   * @title Username
   * @description A display name for the user. Must be between 3 and 50 characters long.
   * @minLength 3
   * @maxLength 50
   */
  username: string
}
```

**3Ô∏è‚É£ Access Settings in Your App**

**`app.tsx`**

```tsx
import { PhyHubClient, connectPhyClient } from "@phygrid/hub-client"
import Settings from "./schema"

const client: PhyHubClient = await connectPhyClient()
const instance = await client.getInstance()
const settings = (await client.getSettings()) as Settings

let counter = 0
setInterval(() => {
  counter += +1
  console.log("Hello, world!", counter)
  console.log("Username:", settings.username)
}, 3000)
```

**4Ô∏è‚É£ Deploy to PhyOS Devices**

**Step 1:** Update the version in `package.json` file

**Step 2:** Build and publish the app:

```bash
yarn run build && yarn run pub
```

**Step 3:** Connect and deploy to your device. See the guide on
[Connecting a device to your installation](/tutorials/build-your-first-edge-app/#-create-an-installation)

### ‚úÖ Validation

The schema automatically provides validation:

- **String fields** with `@minLength` and `@maxLength` ensure proper text length
- **Number fields** with `@minimum` and `@maximum` enforce value ranges
- **Enum fields** restrict values to predefined options
- **Required fields** ensure essential settings are provided

### üñ•Ô∏è Console Rendering

Once you publish your app, the settings schema automatically generates a form
in the Phygrid Console. Users can:

- Configure settings through an intuitive interface.
- See validation errors in real-time.
- Preview how changes will affect the app.
- Save configurations for different environments.

## üìù Examples for the Settings Schema

### üî§ String Type

This example shows how to define a simple string setting with validation
constraints such as minimum and maximum length.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Name
   * @description The user's name. Must be between 3 and 50 characters.
   * @minLength 3
   * @maxLength 50
   */
  name: string
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "title": "Name",
      "description": "The user's name. Must be between 3 and 50 characters.",
      "minLength": 3,
      "maxLength": 50
    }
  },
  "required": ["name"]
}
```

- The `name` field represents a user-configurable string setting.
- Validation constraints are added through the `@minLength` and `@maxLength` annotations,
  ensuring the name is at least 3 characters and no longer than 50 characters.

![Text](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/c94ae267-de95-429a-a238-ccfd9ded7bbe)

### üåç Localized Field

This example shows how to define a localized string setting that supports multiple languages.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Home page
   */
  homePage: {
    /**
     * @title Page title
     * @description Home page title
     * @ui multiLanguageText
     */
    title?: Record<string, string>
  }
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "homePage": {
      "type": "object",
      "properties": {
        "title": {
          "type": "object",
          "title": "Page title",
          "description": "Home page title"
        }
      },
      "title": "Home page"
    }
  }
}
```

**`meta-schema.json`**

```json
{
  "homePage": {
    "title": {
      "ui:field": "multiLanguageText"
    }
  }
}
```

- The `title` field accepts a record of language codes to localized strings.
- The `@ui multiLanguageText` annotation enables a multi-language input interface.

![Localized Text](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/de1a036b-93f0-45c1-8aea-77917136169f)

### ‚úÖ Boolean Type

This example shows how to define a boolean setting for true/false configurations.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Notifications Enabled
   * @description Enables or disables notifications.
   */
  notificationsEnabled: boolean
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "notificationsEnabled": {
      "type": "boolean",
      "title": "Notifications Enabled",
      "description": "Enables or disables notifications."
    }
  },
  "required": ["notificationsEnabled"]
}
```

- The `notificationsEnabled` field accepts a boolean value (true or false).
- This setting is typically rendered as a toggle switch or checkbox in the UI.

![Boolean](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/dcd0c18d-e2ae-4503-9029-2f573d90e867)

### üî¢ Number Type

This example demonstrates how to define a numeric setting with minimum
and maximum value validations.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Age
   * @description The age of the user. Must be between 18 and 120.
   * @minimum 18
   * @maximum 120
   */
  age: number
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "age": {
      "type": "number",
      "title": "Age",
      "description": "The age of the user. Must be between 18 and 120.",
      "minimum": 18,
      "maximum": 120
    }
  },
  "required": ["age"]
}
```

- The `age` field represents a numeric setting.
- The `@minimum` and `@maximum` annotations ensure the
  number falls within a specified range.

![Number](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/ec979c47-4dfc-42a7-8f9d-c7c29abc4983)

### üîó URL Type

This example shows how to define a URL as an optional setting with
validation that ensures the input is a valid URI.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Website
   * @description The user's personal website URL.
   * @format uri
   */
  website?: string
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "website": {
      "type": "string",
      "title": "Website",
      "description": "The user's personal website URL.",
      "format": "uri"
    }
  }
}
```

- The `website` field is optional and accepts a string input that must be a valid URL.
- The `@format uri` annotation enforces URL validation.

![URI](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/5fc65813-7a66-44cc-ae52-554287174299)

### üìã Enum / Dropdown List

This example illustrates how to define an enum setting to provide
a dropdown selection of predefined options.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Favorite Color
   * @description User's favorite color from a predefined list.
   * @enum ["Red", "Green", "Blue", "Yellow"]
   */
  favoriteColor: "Red" | "Green" | "Blue" | "Yellow"
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "favoriteColor": {
      "type": "string",
      "enum": ["Red", "Green", "Blue", "Yellow"],
      "title": "Favorite Color",
      "description": "User's favorite color from a predefined list."
    }
  },
  "required": ["favoriteColor"]
}
```

- The `favoriteColor` field limits user input to one of the predefined options.
- The `@enum` annotation lists all valid choices, which render as a dropdown in the UI.

![Enum](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/3bd60fab-119f-476f-87a9-2ad33fffa296)

### üìÖ Date Type

This example shows how to define a date setting using a string with a date format.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Birth Date
   * @description The user's birth date.
   * @format date
   */
  birthDate: string
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "birthDate": {
      "type": "string",
      "title": "Birth Date",
      "description": "The user's birth date.",
      "format": "date"
    }
  },
  "required": ["birthDate"]
}
```

- The `birthDate` field expects a string formatted as a date (YYYY-MM-DD).
- The `@format date` annotation enforces that the input matches a valid date format.

![Date](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/cd753e1a-0f89-48f0-938b-6cf6cc75cc64)

### üìß Email Type

This example shows how to define an email setting using a string with an email format.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Email Address
   * @description User's email address.
   * @format email
   */
  email: string
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "email": {
      "type": "string",
      "title": "Email Address",
      "description": "User's email address.",
      "format": "email"
    }
  },
  "required": ["email"]
}
```

- The `email` field accepts strings formatted as a valid email address.
- The `@format email` annotation ensures input matches an email pattern.

![Email](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/b868079a-3968-47c5-b530-0c9311c03f60)

### üîí Password Type

This example shows how to define a password setting using a string with a password format.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Password
   * @description User password must be at least 8 characters.
   * @format password
   * @minLength 8
   * @pattern ^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$
   */
  password: string
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "password": {
      "type": "string",
      "title": "Password",
      "description": "User password. Must be at least 8 characters,
       At least one lowercase letter,
       one uppercase letter, one digit and one special character",
      "format": "password",
      "minLength": 8,
      "pattern": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$"
    }
  },
  "required": ["password"]
}
```

- The `password` field is a string with validation on minimum length.
- `@format password` hints UI to render as a password input (masked).
- `@pattern` enforces the presence of:
  - At least one lowercase letter
  - At least one uppercase letter
  - At least one number
  - At least one special character

![Password](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/046e6f08-3283-417b-837f-82f431263a86)

### üìã Array Type

This example shows how to define an array setting.

**`schema.ts`**

```ts
export default interface Settings {
  /**
   * @title Tags
   * @description List of tags associated with the item.
   */
  tags: string[]
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "tags": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "title": "Tags",
      "description": "List of tags associated with the item."
    }
  },
  "required": ["tags"]
}
```

- The `tags` field accepts an array of strings (could be other types).
- Useful for multi-select or lists of values.

![Array](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/f91e8ee5-cfe9-493a-8ba5-8909a4dcbfe1)

### üèóÔ∏è Object Type (Nested Settings)

This example shows how to define nested settings using object type.

**`schema.ts`**

```ts
export interface Address {
  /**
   * @title Street
   */
  street: string

  /**
   * @title City
   */
  city: string
}

export default interface Settings {
  /**
   * @title User Address
   */
  address: Address
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "address": {
      "type": "object",
      "properties": {
        "street": {
          "type": "string",
          "title": "Street"
        },
        "city": {
          "type": "string",
          "title": "City"
        }
      },
      "required": ["street", "city"],
      "title": "User Address"
    }
  },
  "required": ["address"]
}
```

- The `address` field is a nested object with its own typed properties.
- Enables grouping related settings.

![Object / Nested Settings](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/07923e4a-5f99-4947-9f2d-b34da0dfe484)

### üì∑ Media Type

This example shows how to define a media picker for file upload.

**`schema.ts`**

```ts
type Media = {
  ref: "media"
  type: "image/png" | "image/jpg" | "image/jpeg"
  id: string
  url: string
}

export default interface Settings {
  /**
   * @title Profile Picture
   * @ui mediaPicker
   */
  profilePicture: Media
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "profilePicture": {
      "type": "object",
      "properties": {
        "ref": {
          "type": "string",
          "const": "media"
        },
        "type": {
          "type": "string"
        },
        "id": {
          "type": "string"
        },
        "url": {
          "type": "string"
        }
      },
      "required": ["ref", "type", "id", "url"],
      "title": "Profile Picture"
    }
  },
  "required": ["profilePicture"]
}
```

**`meta-schema.json`**

```json
{
  "profilePicture": {
    "ui:field": "mediaPicker"
  }
}
```

- The `profilePicture` allows selecting/uploading media files.
- UI can restrict file types.

![Media](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/ce7ffb98-df35-47e7-b172-5e96c8e941b3)

### üî§ Fonts

This example demonstrates how the Settings Schema
allows users to upload custom font files (e.g., TTF, WOFF, OTF),
which can then be used consistently across the app for typography and branding.

**`schema.ts`**

```ts
type FontType = "otf" | "font/otf" | "font/ttf" | "font/woff" | "font/woff2"

interface FontMedia {
  media?: {
    ref: "media"
    type: FontType
    id: string
    url: string
  }
}

interface Fonts {
  /**
   * @title Light
   */
  light?: FontMedia
  /**
   * @title Regular
   */
  regular?: FontMedia
  /**
   * @title Semi-bold
   */
  semiBold?: FontMedia
  /**
   * @title Bold
   */
  bold?: FontMedia
}

/**
 * @title Example schema
 */
export type Settings = {
  /**
   * @title Fonts
   */
  fonts: Fonts
}

export default Settings
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "fonts": {
      "type": "object",
      "properties": {
        "light": {
          "type": "object",
          "properties": {
            "media": {
              "type": "object",
              "properties": {
                "ref": {
                  "type": "string",
                  "const": "media"
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "otf",
                    "font/otf",
                    "font/ttf",
                    "font/woff",
                    "font/woff2"
                  ]
                },
                "id": {
                  "type": "string"
                },
                "url": {
                  "type": "string"
                }
              },
              "required": ["ref", "type", "id", "url"]
            }
          },
          "title": "Light"
        },
        "regular": {
          "type": "object",
          "properties": {
            "media": {
              "type": "object",
              "properties": {
                "ref": {
                  "type": "string",
                  "const": "media"
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "otf",
                    "font/otf",
                    "font/ttf",
                    "font/woff",
                    "font/woff2"
                  ]
                },
                "id": {
                  "type": "string"
                },
                "url": {
                  "type": "string"
                }
              },
              "required": ["ref", "type", "id", "url"]
            }
          },
          "title": "Regular"
        },
        "semiBold": {
          "type": "object",
          "properties": {
            "media": {
              "type": "object",
              "properties": {
                "ref": {
                  "type": "string",
                  "const": "media"
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "otf",
                    "font/otf",
                    "font/ttf",
                    "font/woff",
                    "font/woff2"
                  ]
                },
                "id": {
                  "type": "string"
                },
                "url": {
                  "type": "string"
                }
              },
              "required": ["ref", "type", "id", "url"]
            }
          },
          "title": "Semi-bold"
        },
        "bold": {
          "type": "object",
          "properties": {
            "media": {
              "type": "object",
              "properties": {
                "ref": {
                  "type": "string",
                  "const": "media"
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "otf",
                    "font/otf",
                    "font/ttf",
                    "font/woff",
                    "font/woff2"
                  ]
                },
                "id": {
                  "type": "string"
                },
                "url": {
                  "type": "string"
                }
              },
              "required": ["ref", "type", "id", "url"]
            }
          },
          "title": "Bold"
        }
      },
      "title": "Fonts"
    }
  },
  "required": ["fonts"]
}
```

**`meta-schema.json`**

```json
{
  "fonts": {
    "ui:field": "mediaPicker"
  }
}
```

- The `mediaPicker` UI component allows users to upload font files in supported formats.
- The `@mediaTypes` directive restricts uploads to specific
  MIME types (e.g., `font/ttf`, `font/woff2`).
- Once uploaded, these fonts can be referenced and applied
  throughout the application for consistent styling and branding.

![Fonts](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/f3064a49-ed9f-446a-b22a-74ccc9d50577)

### üé® Theme

This example demonstrates how the Settings Schema enables users to configure color themes,
allowing consistent branding throughout the application.

**`schema.ts`**

```ts
interface ThemeBaseColors {
  /**
   * @widget color
   */
  primary: string
  /**
   * @widget color
   */
  secondary: string
  /**
   * @widget color
   */
  error: string
  /**
   * @widget color
   */
  success: string
  /**
   * @widget color
   */
  warning: string
}

interface Theme {
  /**
   * @title Colors
   */
  colors: ThemeBaseColors
}

export type Settings = {
  /**
   * @title Theme settings
   */
  theme: Theme
}

export default Settings
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "theme": {
      "type": "object",
      "properties": {
        "colors": {
          "type": "object",
          "properties": {
            "primary": {
              "type": "string"
            },
            "secondary": {
              "type": "string"
            },
            "error": {
              "type": "string"
            },
            "success": {
              "type": "string"
            },
            "warning": {
              "type": "string"
            }
          },
          "required": ["primary", "secondary", "error", "success", "warning"],
          "title": "Colors"
        }
      },
      "required": ["colors"],
      "title": "Theme settings"
    }
  },
  "required": ["theme"]
}
```

**`meta-schema.json`**

```json
{
  "theme": {
    "colors": {
      "primary": {
        "ui:widget": "color"
      },
      "secondary": {
        "ui:widget": "color"
      },
      "error": {
        "ui:widget": "color"
      },
      "success": {
        "ui:widget": "color"
      },
      "warning": {
        "ui:widget": "color"
      }
    }
  }
}
```

- The `ThemeBaseColors` interface defines several color fields
  using the `@widget color` annotation,
  which typically renders a color picker in the UI.
- These fields allow users to select branding colors such as primary, secondary and error states.
- Once configured, these colors can be referenced and applied
  throughout the application for consistent styling and branding.

![Theme](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/8abdab5a-283b-475c-98ed-e465453aa627)

For detailed information about settings overrides and their implementation, visit [learn.phygrid.com](http://learn.phygrid.com).

### üí≥ Payment Picker

The Payment Picker allows users to configure payment methods for
their applications, supporting both online and card-present payment modes. This is essential
for retail, e-commerce, and point-of-sale applications that need to process transactions.

**Supported Payment Modes:**

- **Online Payments:** For e-commerce and remote transactions
- **Card Present:** For in-store terminals and physical card readers

**`schema.ts`**

```ts
type OnlinePaymentData = {
  collectShippingAddress: boolean
}

type CardPresentPaymentData = {
  terminalId: string
}

interface PaymentMethod {
  id: string
  title: string
  mode: "online" | "cardPresent"
  type: "adyenCloudCardTerminal" | "stripeOnlineCheckout"
  data: OnlinePaymentData | CardPresentPaymentData
}

export default interface Settings {
  /**
   * @title Payment Method
   * @description Choose one or more supported payment modes.
   * @ui paymentMethodPicker
   * @uiOptions {
   *   "mode": ["online", "cardPresent"]
   * }
   */
  paymentMethod: PaymentMethod
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "paymentMethod": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "mode": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "data": {
          "type": "object"
        }
      },
      "required": ["id", "title", "mode", "type", "data"],
      "title": "Payment Method",
      "description": "Choose one or more supported payment modes."
    }
  },
  "required": ["paymentMethod"]
}
```

**`meta-schema.json`**

```json
{
  "paymentMethod": {
    "ui:field": "paymentMethodPicker",
    "ui:options": {
      "mode": ["online", "cardPresent"]
    }
  }
}
```

- The `paymentMethodPicker` UI component presents available payment methods for selection
- Users can choose between online and card-present payment modes
- The `@uiOptions` directive filters available payment types based on the selected mode
- Once configured, the app can use the selected payment method to process transactions

**Common Use Cases:**

- **Retail Kiosks:** Configure card terminals for in-store payments
- **E-commerce Apps:** Set up online payment gateways like Stripe
- **Hybrid Solutions:** Support both online and in-person payment methods

![Payment Method](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/647e296d-8180-4790-94e9-327186cf2c01)

### üè¢ Space Picker

The Space Picker allows users to select a specific space from their organization,
enabling space-specific configurations and data fetching. This is essential for
multi-location businesses, retail chains, and organizations that need to customize app
behavior based on different physical locations.

**Common Use Cases:**

- **Multi-location Retail:** Different product catalogs or pricing per store

**`schema.ts`**

```ts
interface SpacePicker {
  id: string
  externalId?: string
  valid?: boolean
}

export default interface Settings {
  /**
   * @title Space Picker
   * @description Select a specific space for location-based configuration.
   * @ui spacePicker
   */
  spacePicker: SpacePicker
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "spacePicker": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "externalId": {
          "type": "string"
        },
        "valid": {
          "type": "boolean"
        }
      },
      "required": ["id"],
      "title": "Space Picker",
      "description": "Select a specific space for location-based configuration."
    }
  },
  "required": ["spacePicker"]
}
```

**`meta-schema.json`**

```json
{
  "spacePicker": {
    "ui:field": "spacePicker"
  }
}
```

- The `spacePicker` UI component presents available spaces from the user's organization
- Users can select a specific space to enable location-based customization
- The selected space ID can be used to fetch space-specific data.
- This enables apps to behave differently based on the physical location where they're deployed

**Common Use Cases:**

- **Endless Aisle:** Different online stock data per store location

![Space Picker](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/8a52fcb5-4ab5-4e02-b438-318a5dbe2e80)

### üîß Peripheral Picker

The Peripheral Picker allows users to select hardware peripherals connected to their device, enabling the screen app to
communicate with external hardware seamlessly.
This is essential for retail, kiosk, and point-of-sale applications that require hardware integration.

**Supported Peripheral Types:**

- **Printers:** Receipt printers, label printers
- **Scanners:** Barcode scanners, QR code readers

**`schema.ts`**

```ts
interface TwinPicker {
  id: string
  ref: "twin"
}
export default interface Settings {
  /**
   * @title Barcode Scanner
   * @description Select a barcode scanner peripheral twin.
   * @ui twinPicker
   * @uiOptions {
   * "twinTypes":["Peripheral"],
   * "twinDescriptors":["phygrid/barcodescanner"]
   * }
   */
  barcodeScanner?: TwinPicker

  /**
   * @title Receipt Printer
   * @description Select a printer peripheral for receipt printing.
   * @ui twinPicker
   * @uiOptions {
   * "twinTypes":["Peripheral"],
   * "twinDescriptors":["phygrid/printer"]
   * }
   */
  receiptPrinter: TwinPicker
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "barcodeScanner": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "ref": {
          "type": "string",
          "const": "twin"
        }
      },
      "required": ["id", "ref"],
      "title": "Barcode Scanner",
      "description": "Select a barcode scanner peripheral twin."
    },
    "receiptPrinter": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "ref": {
          "type": "string",
          "const": "twin"
        }
      },
      "required": ["id", "ref"],
      "title": "Receipt Printer",
      "description": "Select a printer peripheral for receipt printing."
    }
  },
  "required": ["barcodeScanner", "receiptPrinter"]
}
```

**`meta-schema.json`**

```json
{
  "barcodeScanner": {
    "ui:field": "twinPicker",
    "ui:options": {
      "twinTypes": ["Peripheral"],
      "twinDescriptors": ["phygrid/barcodescanner"]
    }
  },
  "receiptPrinter": {
    "ui:field": "twinPicker",
    "ui:options": {
      "twinTypes": ["Peripheral"],
      "twinDescriptors": ["phygrid/printer"]
    }
  }
}
```

- The `peripheralPicker` UI component allows users to select from available hardware peripherals
- `peripheralTypes` and `descriptors` filter the selection to specific device categories
- Once configured, the app can establish connections and communicate with selected peripherals
- Peripheral capabilities are exposed to enable appropriate functionality (scanning, printing, etc.)

**Common Use Cases:**

- **Retail Kiosks:** Barcode scanning for product lookup and receipt printing

![peripheral picker](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/86603833-27ad-4c2b-9c1c-29925c9d4c5e)

### üìã Queue Picker

The Queue Picker allows users to select a specific queue from their organization,
enabling queue-specific data management and customization. This is essential for visitor management,
appointment booking, and operational applications that need to track and manage queues of people or items.

**Common Use Cases:**

- **Appointment Booking:** Manage appointment queues and scheduling
- **People Counter:** Track visitor counts and capacity management
- **Queue Kiosks:** Self-service queue management for customer service
- **Occupancy Signage:** Real-time capacity tracking and display

**`schema.ts`**

```ts
interface QueuePicker {
  /**
   * @title Queue ID
   */
  queueId: string

  /**
   * @title Organisation name
   */
  organization: string

  /**
   * @title Queue endpoint
   */
  queueEndpoint: string
}

export default interface Settings {
  /**
   * @title Queue
   * @description Select a queue for data management and visitor tracking.
   * @ui queuePicker
   */
  queue: QueuePicker
}
```

**`schema.json`**

```json
{
  "schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "queue": {
      "type": "object",
      "properties": {
        "queueId": {
          "type": "string",
          "title": "Queue ID"
        },
        "organization": {
          "type": "string",
          "title": "Organisation name"
        },
        "queueEndpoint": {
          "type": "string",
          "title": "Queue endpoint"
        }
      },
      "required": ["queueId", "organization", "queueEndpoint"],
      "title": "Queue",
      "description": "Select a queue for data management and visitor tracking."
    }
  },
  "required": ["queue"]
}
```

**`meta-schema.json`**

```json
{
  "queue": {
    "ui:field": "queuePicker"
  }
}
```

- The `queuePicker` UI component presents available queues for selection, filtered by the current organization
- Users can select a specific queue to enable queue-specific data management and tracking
- The selected queue's `queueEndpoint` can be used to fetch real-time queue data or send updates
- Queue information includes essential details like ID, organization, endpoint, name, and description

**Common Use Cases:**

- **Appointment Booking:** Selecting a queue to manage appointments and scheduling
- **People Counter:** Assigning a queue to count people entering/exiting a space
- **Occupancy Signage:** Linking to a queue that tracks capacity in real time
- **Queue Kiosk:** Letting users choose a service queue when arriving at a kiosk

![Queue Picker](https://api.phygrid.com/regions/eu/media/v1/assets/media/676514e0adc52b0008c4ddb8/cae2962a-d705-4417-8397-b806d17c5b30)

## ‚öôÔ∏è Settings Overrides

Settings can be overridden at different levels to provide flexibility in configuration management:

- **Device Level:** Settings can be overridden for specific devices, allowing device-specific configurations
- **Space Level:** Settings can be overridden for specific spaces, enabling space-specific customizations

## ‚úÖ Checkpoint

After completing this guide, you should understand:

- How to define basic data types (string, boolean, number, etc.)
- How to work with specialized UI components (media picker, color picker, etc.)
- How to use platform-specific pickers for hardware and services
- The relationship between TypeScript interfaces and generated JSON Schema
- Best practices for creating maintainable and extensible settings schemas

## üîÑ Next Steps

Now that you understand Settings Schemas, you can:

- Configure your app using the settings schema
- Start integrating with peripheral twins
- Explore advanced schema patterns for complex configurations
